{"version":3,"sources":["helpers.ts"],"names":["RNRiveErrorType","isEnum","enumType","enumValue","Object","values","includes","convertErrorFromNativeToRN","errorFromNative","type","message"],"mappings":"AAAA,SAAsBA,eAAtB,QAA6C,SAA7C;AAOA,OAAO,SAASC,MAAT,CACLC,QADK,EAELC,SAFK,EAGkC;AACvC,SAAOC,MAAM,CAACC,MAAP,CAAcH,QAAd,EAAwBI,QAAxB,CAAiCH,SAAjC,CAAP;AACD;AAED,OAAO,SAASI,0BAAT,CAAoCC,eAApC,EAGgB;AACrB,MAAIP,MAAM,CAACD,eAAD,EAAkBQ,eAAe,CAACC,IAAlC,CAAV,EAAmD;AACjD,WAAO;AACLA,MAAAA,IAAI,EAAED,eAAe,CAACC,IADjB;AAELC,MAAAA,OAAO,EAAEF,eAAe,CAACE;AAFpB,KAAP;AAID;;AACD,SAAO,IAAP;AACD","sourcesContent":["import { RNRiveError, RNRiveErrorType } from './types';\n\nexport type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };\nexport type XOR<T, U> = T | U extends object\n  ? (Without<T, U> & U) | (Without<U, T> & T)\n  : T | U;\n\nexport function isEnum<EnumType extends { [key: string]: string }>(\n  enumType: EnumType,\n  enumValue: string\n): enumValue is EnumType[keyof EnumType] {\n  return Object.values(enumType).includes(enumValue);\n}\n\nexport function convertErrorFromNativeToRN(errorFromNative: {\n  type: string;\n  message: string;\n}): RNRiveError | null {\n  if (isEnum(RNRiveErrorType, errorFromNative.type)) {\n    return {\n      type: errorFromNative.type,\n      message: errorFromNative.message,\n    };\n  }\n  return null;\n}\n"]}