import React, { useCallback, useImperativeHandle, useRef } from 'react';
import { requireNativeComponent, UIManager, findNodeHandle, StyleSheet, View } from 'react-native';
import { Direction, LoopMode } from './types';
import { convertErrorFromNativeToRN } from './helpers';
import { Alignment, Fit } from './types';
const VIEW_NAME = 'RiveReactNativeView';
export const RiveViewManager = requireNativeComponent(VIEW_NAME);
const RiveContainer = /*#__PURE__*/React.forwardRef(({
  children,
  onPlay,
  onPause,
  onStop,
  onLoopEnd,
  onStateChanged,
  onError,
  style,
  autoplay = true,
  resourceName,
  url,
  alignment = Alignment.Center,
  fit = Fit.Contain,
  artboardName,
  animationName,
  stateMachineName,
  testID
}, ref) => {
  const riveRef = useRef(null);
  const isUserHandlingErrors = onError !== undefined;
  const onPlayHandler = useCallback(event => {
    const {
      animationName: eventAnimationName,
      isStateMachine
    } = event.nativeEvent;
    onPlay === null || onPlay === void 0 ? void 0 : onPlay(eventAnimationName, isStateMachine);
  }, [onPlay]);
  const onPauseHandler = useCallback(event => {
    const {
      animationName: eventAnimationName,
      isStateMachine
    } = event.nativeEvent;
    onPause === null || onPause === void 0 ? void 0 : onPause(eventAnimationName, isStateMachine);
  }, [onPause]);
  const onStopHandler = useCallback(event => {
    const {
      animationName: eventAnimationName,
      isStateMachine
    } = event.nativeEvent;
    onStop === null || onStop === void 0 ? void 0 : onStop(eventAnimationName, isStateMachine);
  }, [onStop]);
  const onLoopEndHandler = useCallback(event => {
    const {
      animationName: eventAnimationName,
      loopMode
    } = event.nativeEvent;
    onLoopEnd === null || onLoopEnd === void 0 ? void 0 : onLoopEnd(eventAnimationName, loopMode);
  }, [onLoopEnd]);
  const onStateChangedHandler = useCallback(event => {
    const {
      stateMachineName: eventStateMachineName,
      stateName
    } = event.nativeEvent;
    onStateChanged === null || onStateChanged === void 0 ? void 0 : onStateChanged(eventStateMachineName, stateName);
  }, [onStateChanged]);
  const onErrorHandler = useCallback(event => {
    const {
      type,
      message
    } = event.nativeEvent;
    const rnRiveError = convertErrorFromNativeToRN({
      type,
      message
    });

    if (rnRiveError !== null) {
      onError === null || onError === void 0 ? void 0 : onError(rnRiveError);
    }
  }, [onError]);
  const play = useCallback((animationNames = [], loop = LoopMode.Auto, direction = Direction.Auto, areStateMachines = false) => {
    const animationNamesArray = Array.isArray(animationNames) ? animationNames : [animationNames];
    UIManager.dispatchViewManagerCommand(findNodeHandle(riveRef.current), UIManager.getViewManagerConfig(VIEW_NAME).Commands.play, [animationNamesArray, loop, direction, areStateMachines]);
  }, []);
  const pause = useCallback((animationNames = [], areStateMachines = false) => {
    const animationNamesArray = Array.isArray(animationNames) ? animationNames : [animationNames];
    UIManager.dispatchViewManagerCommand(findNodeHandle(riveRef.current), UIManager.getViewManagerConfig(VIEW_NAME).Commands.pause, [animationNamesArray, areStateMachines]);
  }, []);
  const stop = useCallback((animationNames = [], areStateMachines = false) => {
    const animationNamesArray = Array.isArray(animationNames) ? animationNames : [animationNames];
    UIManager.dispatchViewManagerCommand(findNodeHandle(riveRef.current), UIManager.getViewManagerConfig(VIEW_NAME).Commands.stop, [animationNamesArray, areStateMachines]);
  }, []);
  const reset = useCallback(() => {
    UIManager.dispatchViewManagerCommand(findNodeHandle(riveRef.current), UIManager.getViewManagerConfig(VIEW_NAME).Commands.reset, []);
  }, []);
  const fireState = useCallback((triggerStateMachineName, inputName) => {
    UIManager.dispatchViewManagerCommand(findNodeHandle(riveRef.current), UIManager.getViewManagerConfig(VIEW_NAME).Commands.fireState, [triggerStateMachineName, inputName]);
  }, []);
  const setInputState = useCallback((triggerStateMachineName, inputName, value) => {
    if (typeof value === 'boolean') {
      UIManager.dispatchViewManagerCommand(findNodeHandle(riveRef.current), UIManager.getViewManagerConfig(VIEW_NAME).Commands.setBooleanState, [triggerStateMachineName, inputName, value]);
    } else if (typeof value === 'number') {
      UIManager.dispatchViewManagerCommand(findNodeHandle(riveRef.current), UIManager.getViewManagerConfig(VIEW_NAME).Commands.setNumberState, [triggerStateMachineName, inputName, value]);
    }
  }, []);
  useImperativeHandle(ref, () => ({
    setInputState,
    fireState,
    play,
    pause,
    stop,
    reset
  }), [play, pause, stop, reset, setInputState, fireState]);
  return /*#__PURE__*/React.createElement(View, {
    style: [styles.container, style],
    ref: ref,
    testID: testID
  }, /*#__PURE__*/React.createElement(RiveViewManager, {
    ref: riveRef,
    resourceName: resourceName,
    isUserHandlingErrors: isUserHandlingErrors,
    autoplay: autoplay,
    fit: fit,
    url: url,
    style: styles.animation,
    onPlay: onPlayHandler,
    onPause: onPauseHandler,
    onStop: onStopHandler,
    onLoopEnd: onLoopEndHandler,
    onStateChanged: onStateChangedHandler,
    onError: onErrorHandler,
    alignment: alignment,
    artboardName: artboardName,
    animationName: animationName,
    stateMachineName: stateMachineName
  }), /*#__PURE__*/React.createElement(View, {
    style: styles.children
  }, children));
});
const styles = StyleSheet.create({
  children: {
    position: 'absolute',
    width: '100%',
    height: '100%'
  },
  container: {
    flexGrow: 1
  },
  animation: {
    flex: 1
  }
});
export default RiveContainer;
//# sourceMappingURL=Rive.js.map